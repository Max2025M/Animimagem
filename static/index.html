<!DOCTYPE html>
<html lang="pt-BR">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Image â†’ Video Camera Preview</title>
<style>
body{margin:0;background:#111;color:#fff;font-family:Arial,Helvetica,sans-serif}
.app{max-width:1100px;margin:auto;padding:16px}
input[type=file]{width:100%}
.block{border-top:2px solid #333;margin-top:20px;padding-top:20px}
.controls{display:grid;grid-template-columns:1fr 80px;gap:10px;align-items:center}
@media(max-width:600px){.controls{grid-template-columns:1fr}}
select,input,button{padding:10px;border-radius:8px;border:none}
button{background:#00e0ff;font-weight:bold}
.preview{display:flex;justify-content:center;margin-top:10px}
.frame{width:100%;max-width:800px;aspect-ratio:16/9;border:3px solid #fff;overflow:hidden;position:relative;background:#000}
.frame img{position:absolute;will-change:transform}
.status{margin-top:8px}
video{width:100%;margin-top:10px;display:none}
</style>
</head>
<body>
<div class="app">
  <h2>AnimaÃ§Ã£o de CÃ¢mera (Preview)</h2>
  <input id="upload" type="file" multiple accept="image/*"/>
  <div id="list"></div>
</div>

<script>
const list = document.getElementById('list');
const upload = document.getElementById('upload');

upload.addEventListener('change', async (e) => {
  list.innerHTML = '';
  for (const file of e.target.files) {
    await addFileBlock(file);
  }
});

async function addFileBlock(file){
  // criar image object
  const img = await fileToImage(file);
  // crop central 16:9 -> dataURL
  const croppedDataUrl = cropCenterTo16x9(img);

  const block = document.createElement('div');
  block.className = 'block';
  block.innerHTML = `
    <div class="controls">
      <select class="animation">
        <option value="lr">Esquerda â†’ Direita</option>
        <option value="rl">Direita â†’ Esquerda</option>
        <option value="tb">Cima â†’ Baixo</option>
        <option value="bt">Baixo â†’ Cima</option>
        <option value="zoomIn">Zoom In (centro)</option>
        <option value="zoomOut">Zoom Out (centro)</option>
        <option value="cinematic">Diagonal cinematogrÃ¡fico</option>
        <option value="panH">Panorama horizontal</option>
        <option value="panV">Panorama vertical</option>
      </select>
      <input class="speed" type="range" min="0.5" max="3" step="0.1" value="1"/>
      <button class="previewBtn">â–¶ PrÃ©-visualizar</button>
      <button class="renderBtn">ðŸ’¾ Gerar VÃ­deo</button>
    </div>

    <div class="preview">
      <div class="frame"><img src="${croppedDataUrl}"></div>
    </div>

    <div class="status"></div>
    <video controls></video>
  `;
  list.appendChild(block);

  // attach handlers
  block.querySelector('.previewBtn').onclick = () => previewBlock(block, croppedDataUrl);
  block.querySelector('.renderBtn').onclick = () => renderBlock(block, file);
}

// helper: file -> HTMLImageElement
function fileToImage(file){
  return new Promise((resolve, reject) => {
    const url = URL.createObjectURL(file);
    const img = new Image();
    img.onload = () => { URL.revokeObjectURL(url); resolve(img); };
    img.onerror = reject;
    img.src = url;
  });
}

// crop center to 16:9 and return dataURL
function cropCenterTo16x9(img){
  const ratio = 16/9;
  let sw = img.width, sh = img.height;
  let sx = 0, sy = 0;
  if (sw / sh > ratio) {
    sw = Math.round(sh * ratio);
    sx = Math.round((img.width - sw) / 2);
  } else {
    sh = Math.round(sw / ratio);
    sy = Math.round((img.height - sh) / 2);
  }
  const canvas = document.createElement('canvas');
  canvas.width = sw;
  canvas.height = sh;
  const ctx = canvas.getContext('2d');
  ctx.drawImage(img, sx, sy, sw, sh, 0, 0, sw, sh);
  return canvas.toDataURL('image/jpeg', 0.92);
}

// preview animation (uses cropped dataURL)
function previewBlock(block, dataUrl){
  const imgEl = block.querySelector('.frame img');
  const anim = block.querySelector('.animation').value;
  const speed = parseFloat(block.querySelector('.speed').value);

  // for preview we animate transform, scaling similarly to server
  const tempImg = new Image();
  tempImg.onload = () => {
    const fw = block.querySelector('.frame').clientWidth;
    const fh = block.querySelector('.frame').clientHeight;
    const iw = tempImg.width;
    const ih = tempImg.height;
    let scale = Math.max(fw/iw, fh/ih) * 1.3;
    let zoomFrom = scale, zoomTo = scale;
    let sx = (iw*scale - fw) / 2;
    let sy = (ih*scale - fh) / 2;
    let ex = sx, ey = sy;

    switch(anim){
      case 'lr': sx = 0; ex = iw*scale - fw; break;
      case 'rl': sx = iw*scale - fw; ex = 0; break;
      case 'tb': sy = 0; ey = ih*scale - fh; break;
      case 'bt': sy = ih*scale - fh; ey = 0; break;
      case 'zoomIn': zoomTo = scale * 1.25; break;
      case 'zoomOut': zoomFrom = scale * 1.25; break;
      case 'cinematic': sx = 0; sy = ih*scale - fh; ex = iw*scale - fw; ey = 0; zoomTo = scale * 1.15; break;
      case 'panH': sx = iw*scale*0.1; ex = iw*scale*0.9; break;
      case 'panV': sy = ih*scale*0.1; ey = ih*scale*0.9; break;
    }

    let start = null;
    function step(now){
      if(!start) start = now;
      const elapsed = (now - start) / 1000 * speed;
      const p = (elapsed % 6) / 6; // loop every 6s scaled by speed
      const e = p < 0.5 ? 2*p*p : 1 - Math.pow(-2*p+2,2)/2;
      const z = zoomFrom + (zoomTo - zoomFrom) * e;
      const x = sx + (ex - sx) * e;
      const y = sy + (ey - sy) * e;
      imgEl.style.width = (iw * z) + 'px';
      imgEl.style.height = (ih * z) + 'px';
      imgEl.style.transform = `translate(${-x}px,${-y}px)`;
      requestAnimationFrame(step);
    }
    requestAnimationFrame(step);
  };
  tempImg.src = dataUrl;
}

// render: sends cropped image (16:9) to server
async function renderBlock(block, file){
  const status = block.querySelector('.status');
  const video = block.querySelector('video');

  // produce cropped blob from the frame <img> dataURL (we used cropCenterTo16x9 when creating preview)
  const imgEl = block.querySelector('.frame img');
  const dataUrl = imgEl.src;
  // convert dataURL -> blob
  const blob = await (await fetch(dataUrl)).blob();

  const fd = new FormData();
  fd.append('image', blob, 'image.jpg'); // important: name=image
  fd.append('animation', block.querySelector('.animation').value);
  fd.append('speed', block.querySelector('.speed').value);

  status.innerText = 'Enviando para render...';
  let res;
  try {
    res = await fetch('/render', { method: 'POST', body: fd });
  } catch (err) {
    status.innerText = 'Erro ao enviar: ' + err;
    return;
  }

  if (!res.ok) {
    const txt = await res.text().catch(()=>null);
    status.innerText = 'Erro do servidor: ' + (txt || res.status);
    return;
  }

  const json = await res.json();
  const id = json.id;
  status.innerText = 'Job enviado. Id: ' + id;

  // poll progress
  const timer = setInterval(async () => {
    try {
      const p = await fetch('/progress/' + id).then(r => r.json());
      if (p.error) {
        status.innerText = 'Erro no render: ' + p.error;
        clearInterval(timer);
        return;
      }
      status.innerText = 'Render: ' + (p.progress || 0) + '%';
      if (p.done && p.url) {
        clearInterval(timer);
        status.innerText = 'ConcluÃ­do';
        video.src = p.url;
        video.style.display = 'block';
      }
    } catch (err) {
      status.innerText = 'Erro ao checar progresso';
      clearInterval(timer);
    }
  }, 1000);
}
</script>
</body>
</html>
